import tiktoken

class Message:
    def __init__(self):
        self.role = ""
        self.content = ""

    def to_dict(self):
        return {
            "role": self.role,
            "content": self.content
        }


class System(Message):
    def __init__(self, content, name=None):
        super().__init__()
        self.role = "system"
        self.content = content
        self.name = name

    def to_dict(self):
        if self.name is None:
            return {
                "role": self.role,
                "content": self.content
            }
        else:
            return {
                "role": self.role,
                "name": self.name,
                "content": self.content,
            }


class User(Message):
    def __init__(self, content):
        super().__init__()
        self.role = "user"
        self.content = content

class Assistant(Message):
    def __init__(self, content):
        super().__init__()
        self.role = "assistant"
        self.content = content


class Conversation:
    def __init__(self):
        self.messages = []
        self.total_cost = 0

    def add_message(self, message: Message):
        assert isinstance(message, Message)
        self.messages.append(message)

    def add_messages(self, messages: [Message]) -> None:
        for message in messages:
            assert isinstance(message, Message)
            self.messages.append(message)

    def to_openai(self) -> [dict]:
        return [message.to_dict() for message in self.messages]

    def get_cost(self) -> float:
        # assume last message is generated by assistant
        prompt_text = ""
        completion_text = ""
        for message in self.messages[:-1]:
            prompt_text += message.content
        completion_text = self.messages[-1].content

        encoding = tiktoken.encoding_for_model("gpt-4")
        prompt_tokens = encoding.encode(prompt_text)
        completion_tokens = encoding.encode(completion_text)

        price_k_tokens_prompt = 0.03
        price_k_tokens_completion = 0.06
        cost = (len(prompt_tokens)/1000 * price_k_tokens_prompt) + (len(completion_tokens)/1000 * price_k_tokens_completion)
        self.total_cost += cost
        return cost

    def reset(self):
        self.messages = []
        self.total_cost = 0

    def pretty_print(self):
        for message in self.messages:
            print(f"{message.role}: {message.content}")