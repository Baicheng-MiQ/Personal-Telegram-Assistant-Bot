import tiktoken

from dataclasses import dataclass
from typing import Optional

@dataclass
class Message:
    role: str
    content: str

    def to_dict(self):
        return {
            "role": self.role,
            "content": self.content
        }

@dataclass
class System(Message):
    content: str
    name: Optional[str] = None
    role: str = "system"

    def to_dict(self):
        if self.name is None:
            return {
                "role": self.role,
                "content": self.content
            }
        else:
            return {
                "role": self.role,
                "name": self.name,
                "content": self.content,
            }

@dataclass
class User(Message):
    content: str
    role: str = "user"

@dataclass
class Assistant(Message):
    content: str
    role: str = "assistant"


class Conversation:
    def __init__(self):
        self.messages = []
        self.total_cost = 0

    def add_message(self, message: Message):
        assert isinstance(message, Message)
        self.messages.append(message)

    def add_messages(self, messages: [Message]) -> None:
        for message in messages:
            assert isinstance(message, Message)
            self.messages.append(message)

    def to_openai(self) -> [dict]:
        return [message.to_dict() for message in self.messages]

    def get_cost(self) -> float:
        # assume last message is generated by assistant
        prompt_text = ""
        completion_text = ""
        for message in self.messages[:-1]:
            prompt_text += message.content
        completion_text = self.messages[-1].content

        encoding = tiktoken.encoding_for_model("gpt-4")
        prompt_tokens = encoding.encode(prompt_text)
        completion_tokens = encoding.encode(completion_text)

        price_k_tokens_prompt = 0.03
        price_k_tokens_completion = 0.06
        cost = (len(prompt_tokens)/1000 * price_k_tokens_prompt) + (len(completion_tokens)/1000 * price_k_tokens_completion)
        self.total_cost += cost
        return cost

    def reset(self):
        self.messages = []
        self.total_cost = 0

    def pretty_print(self):
        for message in self.messages:
            print(f"{message.role}: {message.content}")